// Express middleware to render the app server-side and expose its state
// to the client

import React from "react"
import Router from "react-router"

import {fetchData, routes} from "../routes"
import {HttpError} from "../errors"
import {intlData} from "../intl"
import HtmlDocument from "./HtmlDocument"


const debug = require("debug")("app:render")


function render(req, res, next) {
  var router = Router.create({
    location: req.url,
    onAbort(redirect) {
      debug("onAbort redirect:", redirect)
      res.redirect(303, redirect.to)
    },
    onError(err) {
      debug("Routing Error", err)
    },
    routes: routes,
  })
  router.run((Root, state) => {
    if (state.routes.some(route => route.isNotFound)) {
      const appHtml = React.renderToString(<Root {...intlData} />)
      res.status(404).send(renderMarkup(appHtml))
      return
    }
    fetchData(state.routes, state.params, state.query)
      .then(
        dataByRouteName => React.renderToString(
          <Root dataByRouteName={dataByRouteName} loading={false} {...intlData} />
        ),
        errorByRouteName => {
          // Handle route errors with dynamic path parts (error is not generated by router but by application code).
          var lastRouteName = state.routes[state.routes.length - 1].name
          var lastRouteError = errorByRouteName[lastRouteName]
          if (lastRouteError instanceof HttpError) {
            res.status(lastRouteError.status)
          }
          return React.renderToString(<Root errorByRouteName={errorByRouteName} loading={false} {...intlData} />)
        },
      )
      .then(appHtml => res.send(renderMarkup(appHtml)))
      .catch(error => next(error))
  })
}


function renderMarkup(appHtml) {
  let webpackStatsPath = "../../webpack/webpack-stats.json"
  let webpackStats
  if (process.env.NODE_ENV === "production") {
    webpackStats = require(webpackStatsPath)
  } else if (process.env.NODE_ENV === "development") {
    webpackStats = require(webpackStatsPath)
    // Do not cache webpack stats: the script file would change since
    // hot module replacement is enabled in the development env
    delete require.cache[require.resolve(webpackStatsPath)]
  }
  const doctype = "<!DOCTYPE html>"
  const css = webpackStats.css.concat([
    process.env.NODE_ENV === "production" ?
      "/assets/bootstrap/css/bootstrap.min.css" :
      "/assets/bootstrap/css/bootstrap.css",
    "/assets/highlight.js/styles/solarized_light.css",
  ])
  const html = React.renderToStaticMarkup(
    <HtmlDocument appHtml={appHtml} css={css} scripts={webpackStats.script} />
  )
  return doctype + html
}


export default render
