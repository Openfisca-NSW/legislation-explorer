// Express middleware to render the app server-side and expose its state
// to the client

import React from "react"
import { renderToString, renderToStaticMarkup } from "react-dom/server"

import { match, RouterContext } from "react-router"
import {IntlProvider} from "react-intl"
import {fetchData, routes} from "../routes"
import {HttpError} from "../errors"
import HtmlDocument from "./HtmlDocument"

const debug = require("debug")("app:render")


function render(req, res, next) {
  match({ routes, location: req.url }, (error, redirectLocation, renderProps) => {
    console.log('RENDERPR', renderProps)
    if (error) {
      debug("Routing Error", error)
      res.status(500).send(error.message)
    } else if (redirectLocation) {
      debug("Route redirect :", redirectLocation)
      res.redirect(302, redirectLocation.pathname + redirectLocation.search)
    } else if (renderProps) {
      const {routes: matchedRoutes, params, query} = renderProps
      // You can also check renderProps.components or renderProps.routes for
      // your "not found" component or route respectively, and send a 404 as
      // below, if you're using a catch-all route.
      fetchData(matchedRoutes, params, query)
        .then(
          //Can you use renderToStaticMarkup here to avoid passing data-reactids in the markup from the server ?
          //Won't it break the transition static html -> React client ?
          dataByRouteName => renderToString(
            <IntlProvider locale="fr">
              <RouterContext {...renderProps}
                dataByRouteName={dataByRouteName}
                loading={false} />
            </IntlProvider>
          ),
          errorByRouteName => {
            // Handle route errors with dynamic path parts (error is not generated by router but by application code).
            var lastRouteName = [...matchedRoutes].pop().name
            var lastRouteError = errorByRouteName[lastRouteName]
            if (lastRouteError instanceof HttpError) {
              res.status(lastRouteError.status)
            }
            return renderToString(
              <IntlProvider locale="fr">
                <RouterContext {...renderProps}
                  errorByRouteName={errorByRouteName}
                  loading={false} />
              </IntlProvider>
            )
          },
        )
        .then(appHtml => res.send(renderMarkup(appHtml)))
        .catch(err => next(err))
    } else {
      //TODO send the not found page as commented above
      /*
      if (state.routes.some(route => route.isNotFound)) {
        const appHtml = renderToString(<Root {...intlData} />)
        res.status(404).send(renderMarkup(appHtml))
        return
      }
      */
      res.status(404).send("Not found")
    }
  })
}


function renderMarkup(appHtml) {
  let webpackStatsPath = "../../webpack/webpack-stats.json"
  let webpackStats
  if (process.env.NODE_ENV === "production") {
    webpackStats = require(webpackStatsPath)
  } else if (process.env.NODE_ENV === "development") {
    webpackStats = require(webpackStatsPath)
    // Do not cache webpack stats: the script file would change since
    // hot module replacement is enabled in the development env
    delete require.cache[require.resolve(webpackStatsPath)]
  }
  const doctype = "<!DOCTYPE html>"
  const css = webpackStats.css.concat([
    process.env.NODE_ENV === "production" ?
      "/assets/bootstrap/css/bootstrap.min.css" :
      "/assets/bootstrap/css/bootstrap.css",
    "/assets/highlight.js/styles/solarized_light.css",
  ])
  const html = renderToStaticMarkup(
    <HtmlDocument appHtml={appHtml} css={css} scripts={webpackStats.script} />
  )
  return doctype + html
}


export default render
